<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>[高频面试题]弄懂JS中的事件循环机制 | 布纳纳大草莓</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="js是一门单线程的非阻塞的脚本语言进程 (process) 和线程 (thread)先看一个形象的比喻： 工厂是计算机的核心 - CPU，承担了所有的计算任务。进程 是工厂里的车间，车间有它的独立资源，车间之间相互独立 。线程 是车间中的工人，多个工人协作完成任务，车间内有一个或多个工人，工人之间共享空间。 假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须">
<meta property="og:type" content="article">
<meta property="og:title" content="[高频面试题]弄懂JS中的事件循环机制">
<meta property="og:url" content="http://yoursite.com/2020/09/03/[%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98]%E5%BC%84%E6%87%82JS%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="布纳纳大草莓">
<meta property="og:description" content="js是一门单线程的非阻塞的脚本语言进程 (process) 和线程 (thread)先看一个形象的比喻： 工厂是计算机的核心 - CPU，承担了所有的计算任务。进程 是工厂里的车间，车间有它的独立资源，车间之间相互独立 。线程 是车间中的工人，多个工人协作完成任务，车间内有一个或多个工人，工人之间共享空间。 假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-09-03T03:06:00.000Z">
<meta property="article:modified_time" content="2020-09-03T15:26:17.319Z">
<meta property="article:author" content="Nicklaus6">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="布纳纳大草莓" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">布纳纳大草莓</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">心脏没有那么脆弱总还会有执着。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-[高频面试题]弄懂JS中的事件循环机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/03/%5B%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%5D%E5%BC%84%E6%87%82JS%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/" class="article-date">
  <time datetime="2020-09-03T03:06:00.000Z" itemprop="datePublished">2020-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      [高频面试题]弄懂JS中的事件循环机制
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="js是一门单线程的非阻塞的脚本语言"><a href="#js是一门单线程的非阻塞的脚本语言" class="headerlink" title="js是一门单线程的非阻塞的脚本语言"></a>js是一门单线程的非阻塞的脚本语言</h2><h3 id="进程-process-和线程-thread"><a href="#进程-process-和线程-thread" class="headerlink" title="进程 (process) 和线程 (thread)"></a>进程 (process) 和线程 (thread)</h3><p>先看一个形象的比喻：</p>
<p>工厂是计算机的核心 - <strong>CPU</strong>，承担了所有的计算任务。<strong>进程</strong> 是工厂里的车间，车间有它的独立资源，车间之间相互独立 。<strong>线程</strong> 是车间中的工人，多个工人协作完成任务，车间内有一个或多个工人，工人之间共享空间。</p>
<p>假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个<strong>CPU</strong>一次只能运行一个任务。<strong>进程</strong> 代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。windows电脑打开任务管理器，就可以查看进程以及每个进程的内存资源信息以及cpu占有率。因此，<strong>进程</strong> 是 cpu 资源分配的最小单位（系统会给它分配内存）。</p>
<p>车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个 <strong>进程</strong> 的内存空间是共享的，每个 <strong>线程</strong> 都可以使用这些共享内存。可是，每间房间的大小不同，有些房间最多只能容纳一个人。里面有人的时候，其他人就不能进去了。这代表一个 <strong>线程</strong> 使用某些共享内存时，其他 <strong>线程</strong> 必须等它结束，才能使用这一块内存。</p>
<p>此时，就好容易理解官方术语对进程和线程的解释了：</p>
<ul>
<li><p><strong>进程</strong> 是 cpu 资源分配的最小单位，是能拥有资源和独立运行的最小单位。</p>
</li>
<li><p><strong>线程</strong> 是 cpu 调度的最小单位，是建立在进程的基础上的一次程序运行单位。一个进程中可以有多个线程。</p>
</li>
</ul>
<h3 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h3><ul>
<li><p>浏览器是多进程的</p>
</li>
<li><p>浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）</p>
</li>
<li><p>每打开一个标签页，就相当于创建了一个独立的浏览器进程。</p>
<p>注意：浏览器也有自己的优化机制，有时候打开多个标签页后，可以在 Chrome 任务管理器中看到，有些进程被合并了（所以每一个标签页对应一个进程并不是绝对的）</p>
</li>
</ul>
<h3 id="为什么-js-是单线程？"><a href="#为什么-js-是单线程？" class="headerlink" title="为什么 js 是单线程？"></a>为什么 js 是单线程？</h3><p>js是单线程，意味着同一时间内只能做一件事情。那么为什么js不能有多个线程呢？</p>
<p>js的单线程，是由它的用途决定的：与用户互动以及操作DOM，主要执行环境是浏览器。试想，如果js是多线程，当两个线程同时对一个DOM元素进行操作时，一个对其添加事件，另一个删除此DOM元素，浏览器该以哪个线程为准呢？</p>
<p>因此，为了避免上述例子中的情况发生,js选择只用一个主线程来执行代码，保证了程序执行的一致性。</p>
<p>但是，单线程在保证了程序执行的一致性的同时也限制了js的效率。为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。</p>
<h3 id="阻塞（blocking）和非阻塞-non-blocking"><a href="#阻塞（blocking）和非阻塞-non-blocking" class="headerlink" title="阻塞（blocking）和非阻塞(non-blocking)"></a>阻塞（blocking）和非阻塞(non-blocking)</h3><p>先看两个比方：</p>
<p>我去超市买包薯片，老板告诉我货架上没货了，马上去库房拿，这过程中，老板要我站着等他，直到他拿到货出来给我。这个过程就是 <strong>阻塞</strong>。</p>
<p>如果老板告诉我，可以先回去，他一会去库房拿，拿到了之后打电话给我。这个过程，就是 <strong>非阻塞</strong> 的，我不用等待，还可以干其他的事情。</p>
<p>因此，<strong>阻塞和非阻塞关注的是程序等待调用结果时的状态。</strong></p>
<p><strong>阻塞</strong> 的意思是，在调用结果返回响应前，线程会被挂起占用，程序无法继续往下走。</p>
<p>而 <strong>非阻塞</strong> 的线程则不会挂起，后面的代码能够继续往下执行。</p>
<h3 id="执行栈-execution-stack"><a href="#执行栈-execution-stack" class="headerlink" title="执行栈(execution stack)"></a>执行栈(execution stack)</h3><p>js 代码在执行代码时，JS 会给调用代码生成一个执行环境，也叫执行上下文（Context），（这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。）并将其压入执行上下文栈，首先进入栈底的是全局上下文，然后是函数的执行上下文（Execution Context），函数执行完之后，函数上下文从栈中弹出，直到退出浏览器，全局上下文才从栈底弹出。</p>
<p>以上就是同步代码的执行，那么异步代码（比如ajax发送请求）呢？</p>
<h3 id="单线程的-js-是如何实现-“非阻塞”，执行异步代码的？"><a href="#单线程的-js-是如何实现-“非阻塞”，执行异步代码的？" class="headerlink" title="单线程的 js 是如何实现 “非阻塞”，执行异步代码的？"></a>单线程的 js 是如何实现 “非阻塞”，执行异步代码的？</h3><p>js 执行异步代码而不用等待，是因有为有 <strong>消息队列</strong> 和 <strong>事件循环</strong> 。</p>
<ul>
<li><p><strong>任务队列（Task Queue）</strong>：任务队列是一个先进先出的队列，它里面存放着各种任务。</p>
</li>
<li><p><strong>事件循环（Event Loop）</strong>：事件循环是指主线程重复从消息队列中取消息、执行的过程。</p>
</li>
</ul>
<h4 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h4><ul>
<li><p>任务分为同步任务和异步任务</p>
</li>
<li><p>同步任务都在主线程上自上而下执行，形成一个执行栈。</p>
</li>
<li><p>异步事件（包括宏任务和微任务）返回结果后，进入任务队列，但是不会立刻执行回调。</p>
</li>
<li><p>执行栈中的同步任务都执行完毕，主线程处于闲置状态时，主线程会开始检查任务队列中的任务，取出排在第一位的异步任务，将其对应的回调放入执行栈中，然后执行其中的同步代码。</p>
</li>
<li><p>如此循环……</p>
</li>
</ul>
<h4 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h4><p>以上的事件循环过程是一个宏观的表述，实际上因为异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：宏任务（macro ）task 和微任务（microtask）。</p>
<h5 id="宏任务-（macro）task"><a href="#宏任务-（macro）task" class="headerlink" title="宏任务 （macro）task"></a>宏任务 （macro）task</h5><p>每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。</p>
<p>浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个macro task 执行开始前，对页面进行重新渲染。流程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(macro)task -&gt; 渲染 -&gt; (macro)task -&gt; ...</span><br></pre></td></tr></table></figure>

<p><strong>主要包含</strong>：script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境)</p>
<h5 id="微任务-microtask"><a href="#微任务-microtask" class="headerlink" title="微任务 microtask"></a>微任务 microtask</h5><p>microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前。</p>
<p>所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染。也就是说，在某一个task执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）。</p>
<p><strong>主要包含</strong>：Promise.then、MutaionObserver、process.nextTick(Node.js 环境)</p>
<h5 id="运行机制：先微后宏"><a href="#运行机制：先微后宏" class="headerlink" title="运行机制：先微后宏"></a>运行机制：先微后宏</h5><p>在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下：</p>
<ul>
<li>执行一个宏任务（执行栈中没有就从任务队列中获取）</li>
<li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li>
<li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务</li>
<li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li>
<li>渲染完毕后，JS线程继续接管，开始下一个宏任务（从任务队列中获取）</li>
</ul>
<p><strong>先执行主任务（栈中的同步任务），把异步任务放入循环队列当中，等待主任务执行完，再执行队列中的异步任务。异步任务先执行微观任务，再执行宏观任务。一直这样循环，反复执行，就是事件循环机制。</strong></p>
<h4 id="题目检测："><a href="#题目检测：" class="headerlink" title="题目检测："></a>题目检测：</h4><h5 id="1-下面代码的打印顺序？"><a href="#1-下面代码的打印顺序？" class="headerlink" title="1. 下面代码的打印顺序？"></a>1. 下面代码的打印顺序？</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'开始111'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout111'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise111'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise222'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'开始222'</span>);</span><br></pre></td></tr></table></figure>

<p>​    答案：打印顺序为：’开始111’，’开始222’，’promise111’，’promise222’，’setTimeout111’</p>
<p>​    分析：</p>
<ol>
<li><p>遇到同步任务，直接打印 ‘开始111’</p>
</li>
<li><p>遇到异步中的宏任务 setTimeout ，放入任务队列中等待执行</p>
<ol start="3">
<li>遇到异步中的微任务 Promise.then，放入任务队列中等待执行</li>
<li>遇到同步任务，直接打印 “开始222”。<ol start="4">
<li>同步任务执行完，检查任务队列中的异步任务，先执行微任务 Promise.then，再执行宏任务 setTimeout</li>
</ol>
</li>
</ol>
</li>
</ol>
<h5 id="2-下面代码的打印顺序？"><a href="#2-下面代码的打印顺序？" class="headerlink" title="2.下面代码的打印顺序？"></a>2.下面代码的打印顺序？</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'开始111'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'timeout111'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'promise111'</span>);</span><br><span class="line">   resolve();</span><br><span class="line">   setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'timeout222'</span>));</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'promise222'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'开始222'</span>);</span><br></pre></td></tr></table></figure>

<p>答案：打印顺序为：’开始111’，’promise111’，’开始222’，’promise222’，’timeout111’，’timeout222’</p>
<p>分析：</p>
<ol>
<li>遇到同步代码，先打印 “开始111”</li>
<li>遇到异步中的宏任务 setTimeout，放入队列，等待执行 </li>
<li>遇到Promise函数，函数直接执行，打印 “promise111”</li>
<li>遇到异步中的宏任务 setTimeout ，放入队列，等待执行</li>
<li>遇到异步中的微任务 Promise.then，放入队列，等待执行</li>
<li>遇到同步，打印 “开始222”。</li>
<li>同步任务执行完，检查任务队列中的异步任务，先执行微任务 Promise.then，再依次执行两个宏任务 setTimeout</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/03/[%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98]%E5%BC%84%E6%87%82JS%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/" data-id="ckemyqk8v0000movg1l5l0ulc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/09/05/git%E5%8D%8F%E5%90%8C%E5%BC%80%E5%8F%91%E6%8B%89%E5%8F%96%E9%A1%B9%E7%9B%AE/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          git协同开发拉取项目
        
      </div>
    </a>
  
  
    <a href="/2020/09/02/git%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">git踩坑记录</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/09/05/git%E5%8D%8F%E5%90%8C%E5%BC%80%E5%8F%91%E6%8B%89%E5%8F%96%E9%A1%B9%E7%9B%AE/">git协同开发拉取项目</a>
          </li>
        
          <li>
            <a href="/2020/09/03/%5B%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%5D%E5%BC%84%E6%87%82JS%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/">[高频面试题]弄懂JS中的事件循环机制</a>
          </li>
        
          <li>
            <a href="/2020/09/02/git%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/">git踩坑记录</a>
          </li>
        
          <li>
            <a href="/2020/09/01/git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/">Git 分支管理</a>
          </li>
        
          <li>
            <a href="/2020/08/28/vue%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AETodoMVC%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%80%9D%E8%80%83/">vue入门项目TodoMVC实现和思考</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Nicklaus6<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>